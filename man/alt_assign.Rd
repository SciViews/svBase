% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/alt_assign.R
\name{alt_assign}
\alias{alt_assign}
\alias{\%->\%}
\alias{\%<-\%}
\alias{collect.default}
\title{Alternate assignment (multiple and/or collect results from dplyr)}
\usage{
value \%->\% x

x \%<-\% value

\method{collect}{default}(x, ...)
}
\arguments{
\item{value}{The object to be assigned.}

\item{x}{A name, or a name structure for multiple (deconstructing)
assignment, or any object that does not have a specific [dplyr::collect[])
method for \code{collect.default()}.}

\item{...}{further arguments passed to the method (not used for the default
one)}
}
\value{
These operators invisibly return \code{value}. \code{collect.default()} simply
return \code{x}.
}
\description{
These alternate assignment operators can be used to perform
multiple assignment (also known as destructuring assignment). These are
imported from the {zeallot} package (see the corresponding help page at \link[zeallot:operator]{zeallot::operator} for complete description). They also performs a \code{\link[dplyr:compute]{dplyr::collect()}} allowing to get results from dplyr extensions like {dtplyr} for data.tables, or {dbplyr} for databases. Finally these two assignment operators also make sure that the preferred data frame object is returned by using \code{\link[=default_dtx]{default_dtx()}}.
}
\details{
These assignation operator are overloaded to get interesting
properties in the context of {tidyverse} pipelines and to make sure to always
return our preferred data frame object (data.frame, data.table, or tibble).
Thus, before being assigned, \code{value} is modified by calling
\code{\link[dplyr:compute]{dplyr::collect()}} on it and by applying \code{\link[=default_dtx]{default_dtx()}}.
}
\examples{
# The alternate assignment operator performs three steps:
# 1) Collect results from {dbplyr} or {dtplyr}
library(dplyr)
library(data.table)
library(dtplyr)
library(svBase)
dtt <- data.table(x = 1:5, y = rnorm(5))
dtt |>
  mutate(x2 = x^2) |>
  select(x2, y) ->
  res

print(res)
class(res) # This is a data frame

dtt |>
  lazy_dt() |>
  mutate(x2 = x^2) |>
  select(x2, y) ->
  res

print(res)
class(res) # This is NOT a data frame

# Same pipeline, but assigning with \%->\%
dtt |>
  lazy_dt() |>
  mutate(x2 = x^2) |>
  select(x2, y) \%->\%
  res

print(res)
class(res) # res is the preferred data frame (data.table by default)

# 2) Convert data frame in the chosen format using default_dtx()
dtf <- data.frame(x = 1:5, y = rnorm(5))
class(dtf)
res \%<-\% dtf
class(res) # A data.table by default
# but it can be changed with options("SciViews.as_dtx)

# 3) If the {zeallot} syntax is used, make multiple assignment
c(X, Y) \%<-\% dtf # Variables of dtf assigned to different names
X
Y

# The \%->\% is meant to be used in pipelines, otherwise it does the same
}
