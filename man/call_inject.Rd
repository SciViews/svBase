% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/call_inject.R
\name{call_inject_first_arg}
\alias{call_inject_first_arg}
\alias{is_call_fn}
\title{Inject first argument in a call, usually data = (.)}
\usage{
call_inject_first_arg(
  call,
  arg = "data",
  value = as.symbol("."),
  if_not = NULL,
  abort_msg = "Argument 'call' must be a 'call' object with a function call.",
  abort_frame = caller_env()
)

is_call_fn(call)
}
\arguments{
\item{call}{A call object, usually a function call.}

\item{arg}{The name of the argument to inject, usually 'data'.}

\item{value}{The value to inject, usually the symbol '.'.}

\item{if_not}{If the call is not a function call, this value is returned
(by default, \code{NULL}).}

\item{abort_msg}{The message to use in case the call is not a function call.}

\item{abort_frame}{The environment to use for the error message, by default,
the caller environment.}
}
\value{
A modified call with the first argument injected, or \code{if_not} if the
the \verb{data=} argument is already explicitly in the initial call. For
\code{is_call_fn()}, \code{TRUE} if call is a call to a function (either \code{fun(args)}
or \code{ns::fun(args)}), \code{FALSE} otherwise.
}
\description{
In case the \code{data = (.)} is missing in a call to a "dot-data"
function (a function that defines that its first argument \verb{data=} could be
missing, and it this case, it is considered to be \code{.}), this function does
the injection of the first argument in the call.
}
\examples{
call1 <- quote(my_function(x, y))
is_call_fn(call1)
call_inject_first_arg(call1)

# This is not a correct function call
call2 <- quote(letters)
is_call_fn(call2)
#call_inject_first_arg(call2) # Would raise an error

# This is a function call, but data= is already explicitly defined
call3 <- quote(my_function(x, y, data = my_data))
is_call_fn(call3)
call_inject_first_arg(call3) # Return NULL
}
