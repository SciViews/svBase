% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sciviews_functions.R
\name{sciviews_functions}
\alias{sciviews_functions}
\alias{list_sciviews_functions}
\alias{all_of}
\alias{group_vars_}
\alias{group_rows_}
\alias{group_data_}
\alias{group_indices_}
\alias{group_keys_}
\alias{groups_}
\alias{group_size_}
\alias{n_groups_}
\alias{group_by_}
\alias{ungroup_}
\alias{rename_}
\alias{rename_with_}
\alias{filter_}
\alias{select_}
\alias{mutate_}
\alias{transmute_}
\alias{summarise_}
\alias{reframe_}
\alias{arrange_}
\alias{full_join_}
\alias{left_join_}
\alias{right_join_}
\alias{inner_join_}
\alias{bind_rows_}
\alias{count_}
\alias{tally_}
\alias{add_count_}
\alias{add_tally_}
\alias{bind_cols_}
\alias{pull_}
\alias{distinct_}
\alias{drop_na_}
\alias{replace_na_}
\alias{pivot_longer_}
\alias{pivot_wider_}
\alias{uncount_}
\alias{unite_}
\alias{separate_}
\alias{separate_rows_}
\alias{fill_}
\alias{extract_}
\title{SciViews functions (mainly from collapse and data.table) to manipulate data frames}
\usage{
list_sciviews_functions()

all_of(x)

group_vars_(.data = (.), return = "names")

group_rows_(.data = (.))

group_data_(.data = (.))

group_indices_(.data = (.), ...)

group_keys_(.data = (.), ...)

groups_(.data = (.))

group_size_(.data = (.))

n_groups_(.data = (.))

group_by_(
  .data = (.),
  ...,
  .add = FALSE,
  .drop = NULL,
  .sort = get_collapse("sort"),
  .decreasing = FALSE,
  .na.last = TRUE,
  .return.groups = TRUE,
  .return.order = .sort,
  .method = "auto"
)

ungroup_(.data = (.), ..., .na.last = TRUE, .method = "auto")

rename_(.data = (.), ...)

rename_with_(.data = (.), .fn, .cols = ~everything(), ...)

filter_(.data = (.), ..., .by = NULL, .preserve = FALSE)

select_(.data = (.), ...)

mutate_(
  .data = (.),
  ...,
  .by = NULL,
  .keep = "all",
  .before = NULL,
  .after = NULL,
  .cols = NULL
)

transmute_(.data, ...)

summarise_(
  .data = (.),
  ...,
  .by = NULL,
  .groups = "drop_last",
  .keep.group_vars = TRUE,
  .cols = NULL
)

reframe_(
  .data,
  ...,
  .by = NULL,
  .groups = "drop",
  .keep.group_vars = TRUE,
  .cols = NULL
)

arrange_(
  .data = (.),
  ...,
  .by_group = FALSE,
  .locale = "C",
  .decreasing = FALSE
)

full_join_(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)

left_join_(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)

right_join_(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)

inner_join_(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)

bind_rows_(..., .id = NULL)

count_(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = dplyr::group_by_drop_default(x),
  sort_cat = TRUE,
  decreasing = FALSE
)

tally_(
  x,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  sort_cat = TRUE,
  decreasing = FALSE
)

add_count_(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = NULL,
  sort_cat = TRUE,
  decreasing = FALSE
)

add_tally_(
  x,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  sort_cat = TRUE,
  decreasing = FALSE
)

bind_cols_(
  ...,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)

pull_(.data, var = -1, name = NULL, ...)

distinct_(.data, ..., .keep_all = FALSE)

drop_na_(data, ...)

replace_na_(data, replace, ...)

pivot_longer_(data, cols, names_to = "name", values_to = "value", ...)

pivot_wider_(data, names_from = name, values_from = value, ...)

uncount_(data, weights, .remove = TRUE, .id = NULL)

unite_(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)

separate_(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  ...
)

separate_rows_(data, ..., sep = "[^[:alnum:].]+", convert = FALSE)

fill_(data, ..., .direction = c("down", "up", "downup", "updown"))

extract_(
  data,
  col,
  into,
  regex = "([[:alnum:]]+)",
  remove = TRUE,
  convert = FALSE,
  ...
)
}
\arguments{
\item{x}{A data frame (data.frame, data.table or tibble's tbl_df).}

\item{.data}{A data frame (data.frame, data.table or tibble's tbl_df)}

\item{return}{What to return: \code{"data"} or \code{1}, \code{"unique"} or \code{2} for unique
rows of grouping columns, \code{"names"} or \code{3} (default) for names of grouping
columns, \code{"indices"} or \code{4} for integer indices of grouping columns,
\code{"named_indices"} or \code{5} for named indices, \code{"logicial"} or \code{6} for logical
selection vector of grouping columns, or \code{"named_logical"} or \code{7} for named
logical.}

\item{...}{Arguments dependent to the context of the function and most of
the time, not evaluated in a standard way (cf. the tidyverse approach).}

\item{.add}{If \code{TRUE}, the grouping variables are added to the existing ones.}

\item{.drop}{Are levels with no observations dropped (\code{TRUE} by default).}

\item{.sort}{If \code{TRUE} groups are sorted.}

\item{.decreasing}{Is sorting done in decreasing order (\code{FALSE} by default)?}

\item{.na.last}{How to treat missing values in groups? Assign them to the last
group by default (\code{TRUE}).}

\item{.return.groups}{If \code{TRUE}, the grouping variables are returned in the GRP
object (default).}

\item{.return.order}{If \code{TRUE}, the order of the grouping variables is
returned in the object (by default, same value as \verb{sort=}).}

\item{.method}{The algorithm to use for grouping:  \code{"radix"}, \code{"hash"}, or
\code{"auto"} (by default). \code{"auto"} chose \code{"radix"} when \code{sort = TRUE} and
\code{"hash"} otherwise.}

\item{.fn}{A function to use.}

\item{.cols}{The list of the column where to apply the transformation. For
the moment, only all existing columns, which means \code{.cols = everything()}
is implemented}

\item{.by}{A list of names of the columns to use for grouping the data.}

\item{.preserve}{When data is grouped, do we preserve grouping or recalculate
it according to the new data frame obtained?}

\item{.keep}{Which columns to keep. The default is \code{"all"}, possible values
are \code{"used"}, \code{"unused"}, or \code{"none"} (see \code{\link[=mutate]{mutate()}}).}

\item{.before}{Place new columns before this one.}

\item{.after}{Place new columns after this one.}

\item{.groups}{How to treat the grouping variables in the result? Possible
values are \code{"drop_last"} (default), \code{"drop"} (no grouping variables),
\code{"keep"} (keep all grouping variables), or \code{"rowwise"} (not implemented
yet).}

\item{.keep.group_vars}{If \code{TRUE} (by default), the grouping variables are
kept in the result.}

\item{.by_group}{Logical. If \code{TRUE} rows are first arranger by the grouping
variables in any. \code{FALSE} by default.}

\item{.locale}{The locale to sort character vectors in. If \code{NULL}(default),
use \code{"C"} locale.}

\item{y}{A second data frame.}

\item{by}{A list of names of the columns to use for joining the two data
frames.}

\item{suffix}{The suffix to the column names to use to differentiate the
columns that come from the first or the second data frame. By default it is
\code{c(".x", ".y")}.}

\item{copy}{This argument is there for compatibility with the "t" matching
functions, but it is not used here.}

\item{.id}{The name of the column for the origin id, either names if all
other arguments are named, or numbers.}

\item{wt}{Frequency weights. Can be \code{NULL} or a variable. Use data masking.}

\item{sort}{If \code{TRUE} largest group will be shown on top.}

\item{name}{The name of the new column in the output (\code{n} by default, and no
existing column must have this name, or an error is generated).4}

\item{sort_cat}{Are levels sorted (\code{TRUE} by default).}

\item{decreasing}{Is sorting done in decreasing order (\code{FALSE} by default)?}

\item{.name_repair}{How should the name be "repaired" to avoid duplicate
column names? See \code{\link[dplyr:bind_cols]{dplyr::bind_cols()}} for more details.}

\item{var}{A variable specified as a name, a positive or a negative integer
(counting from the end). The default is \code{-1} and returns last variable.}

\item{.keep_all}{If \code{TRUE} keep all variables in \code{.data}.}

\item{data}{A data frame, or for \code{replace_na()} a vector or a data frame.}

\item{replace}{If \code{data} is a vector, a unique value to replace \code{NA}s,
otherwise, a list of values, one per column of the data frame.}

\item{cols}{A selection of the columns using tidy-select syntax,
see\code{\link[tidyr:pivot_longer]{tidyr::pivot_longer()}}.}

\item{names_to}{A character vector with the name or names of the columns for
the names.}

\item{values_to}{A string with the name of the column that receives the
values.}

\item{names_from}{The column or columns containing the names (use tidy
selection and do not quote the names).}

\item{values_from}{Idem for the column or columns that contain the values.}

\item{weights}{A vector of weight to use to "uncount" \code{data}.}

\item{.remove}{If \code{TRUE}, and \code{weights} is the name of a column, that column
is removed from \code{data}.}

\item{col}{The name quoted or not of the new column with united variable.}

\item{sep}{Separator to use between values for united or separated columns.}

\item{remove}{If \code{TRUE} the initial columns that are separated are also
removed from \code{data}.}

\item{na.rm}{If \code{TRUE}, \code{NA}s are eliminated before uniting the values.}

\item{into}{Name of the new column to put separated variables. Use \code{NA} for
items to drop.}

\item{convert}{If \verb{'TRUE} resulting values are converted into numeric,
integer or logical.}

\item{.direction}{Direction in which to fill missing data: \code{"down"} (by
default), \code{"up"}, or \code{"downup"} (first down, then up), \code{"updown"}
(the opposite).}

\item{regex}{A regular expression used to extract the desired values (use one
group with \code{(} and \verb{)} for each element of \code{into}).}
}
\value{
See corresponding "non-SciViews" function for the full help page with
indication of the return values.
}
\description{
A SciViews::R version of the tidyverse functions in \{dplyr\}
and \{tidyr\} with standard evaluation, and non-standard evaluation trough
formulas. These functions end with an underscore \verb{_}. Avoid mixing tidy,
speedy and SciViews functions in the same pipeline.
}
\note{
The \code{\link[=ssummarise]{ssummarise()}} function does not support \code{n()} as does
\code{\link[dplyr:summarise]{dplyr::summarise()}}. You can use \code{\link[=fn]{fn()}} instead, but then, you must give a
variable name as argument. The \code{\link[=fn]{fn()}} alternative can also be used in
\code{\link[=summarise]{summarise()}} for homogeneous syntax between the two.
From \{dplyr\}, the \code{\link[=slice]{slice()}} and \code{slice_xxx()} functions are not added yet
because they are not available for \{dbplyr\}. Also \code{\link[=anti_join]{anti_join()}},
\code{\link[=semi_join]{semi_join()}} and \code{\link[=nest_join]{nest_join()}} are not implemented yet.
From \{tidyr\} \code{\link[=expand]{expand()}}, \code{\link[=chop]{chop()}}, \code{\link[=unchop]{unchop()}}, \code{\link[=nest]{nest()}}, \code{\link[=unnest]{unnest()}},
\code{\link[=unnest_longer]{unnest_longer()}}, \code{\link[=unnest_wider]{unnest_wider()}}, \code{\link[=hoist]{hoist()}}, \code{\link[=pack]{pack()}} and \code{\link[=unpack]{unpack()}} are
not implemented yet.
}
\examples{
# TODO...
}
