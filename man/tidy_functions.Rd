% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidy_functions.R
\name{tidy_functions}
\alias{tidy_functions}
\alias{list_tidy_functions}
\alias{filter_ungroup}
\alias{mutate_ungroup}
\alias{transmute_ungroup}
\title{Tidy functions (mainly from dplyr and tidyr) to manipulate data frames}
\usage{
list_tidy_functions()

filter_ungroup(.data, ...)

mutate_ungroup(.data, ..., .keep = "all")

transmute_ungroup(.data, ...)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a lazy
data frame (e.g. from dbplyr or dtplyr). See \code{\link[dplyr:mutate]{dplyr::mutate()}} for more
details.}

\item{...}{Arguments dependent to the context of the function and most of
the time, not evaluated in a standard way (cf. the tidyverse approach).}

\item{.keep}{Which columns to keep. The default is \code{"all"}, possible values
are \code{"used"}, \code{"unused"}, or \code{"none"} (see \code{\link[dplyr:mutate]{dplyr::mutate()}}).}
}
\value{
See corresponding "non-t" function for the full help page with
indication of the return values. \code{\link[=list_tidy_functions]{list_tidy_functions()}} returns a list of
all the tidy(verse) functions that have their speedy "s" counterpart, see
\link{speedy_functions}.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}

\emph{These function are deprecated to the benefit of the functions whose name
ends with an underscore \verb{_} (e.g., \code{select()} -> \code{\link[svTidy:sciviews_functions]{svTidy::select_()}}) in the
svTidy package}.

The Tidyverse defines a coherent set of tools to manipulate
data frames that use a non-standard evaluation and sometimes require extra
care. These functions, like \code{\link[dplyr:mutate]{dplyr::mutate()}} or \code{\link[dplyr:summarise]{dplyr::summarise()}} are
defined in the \{dplyr\} and \{tidyr\} packages. When using variants, like
\{dtplyr\} for \strong{data.frame} objects, or \{dbplyr\} to work with external
databases, successive commands in a pipeline are pooled together but not
computed. One has to \code{\link[dplyr:compute]{dplyr::collect()}} the result to get its final form.
Most of the tidy functions that have their "speedy" counterpart prefixed with
"s" are listed with\code{\link[=list_tidy_functions]{list_tidy_functions()}}. Their main usages are (excluding
less used arguments, or those that are not compatibles with the speedy "s"
counterpart functions):
\itemize{
\item \code{group_by(.data, ...)}
\item \code{ungroup(.data)}
\item \code{rename(.data, ...)}
\item \code{rename_with(.data, .fn, .cols = everything(), ...)}
\item \code{filter(.data, ...)}
\item \code{select(.data, ...)}
\item \code{mutate(.data, ..., .keep = "all")}
\item \code{transmute(.data, ...)}
\item \code{summarise(.data, ...)}
\item \code{full_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{left_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{right_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{inner_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{bind_rows(..., .id = NULL)}
\item \code{bind_cols(..., .name_repair = c("unique", "universal", "check_unique", "minimal"))}
\item \code{arrange(.data, ..., .by_group = FALSE)}
\item \code{count(x, ..., wt = NULL, sort = FALSE, name = NULL)}
\item \code{tally(x, wt = NULL, sort = FALSE, name = NULL)}
\item \code{add_count(x, ..., wt = NULL, sort = FALSE, name = NULL)}
\item \code{add_tally(x, wt = NULL, sort = FALSE, name = NULL)}
\item \code{pull(.data, var = -1, name = NULL)}
\item \code{distinct(.data, ..., .keep_all = FALSE)}
\item \code{drop_na(data, ...)}
\item \code{replace_na(data, replace)}
\item \code{pivot_longer(data, cols, names_to = "name", values_to = "value")}
\item \code{pivot_wider(data, names_from = name, values_from = value)}
\item \code{uncount(data, weights, .remove = TRUE, .id = NULL)}
\item \code{unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)}
\item \code{separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE, convert = FALSE)}
\item \code{separate_rows(data, ..., sep = "[^[:alnum:].]+", convert = FALSE)}
\item \code{fill(data, ..., .direction = c("down", "up", "downup", "updown"))}
\item \code{extract(data, col, into, regex = "([[:alnum:]]+)", remove = TRUE, convert = FALSE)}
plus the functions defined here under.
}
}
\note{
The help page here is very basic and it aims mainly to list all the
tidy functions. For more complete help, see the \{dplyr\} or \{tidyr\}
packages. From \{dplyr\}, the \code{\link[=slice]{slice()}} and \code{slice_xxx()} functions are not
added yet because they are not available for \{dbplyr\}. Also
\code{\link[dplyr:filter-joins]{dplyr::anti_join()}}, \code{\link[dplyr:filter-joins]{dplyr::semi_join()}} and \code{\link[dplyr:nest_join]{dplyr::nest_join()}} are not
implemented yet. From \{dplyr\}, the \code{\link[dplyr:slice]{dplyr::slice()}} and \code{slice_xxx()}
functions are not added yet because they are not available for \{dbplyr\}.
From \{tidyr\} \code{\link[tidyr:expand]{tidyr::expand()}}, \code{\link[tidyr:chop]{tidyr::chop()}}, \code{\link[tidyr:chop]{tidyr::unchop()}},
\code{\link[tidyr:nest]{tidyr::nest()}}, \code{\link[tidyr:unnest]{tidyr::unnest()}}, \code{\link[tidyr:unnest_longer]{tidyr::unnest_longer()}},
\code{\link[tidyr:unnest_wider]{tidyr::unnest_wider()}}, \code{\link[tidyr:hoist]{tidyr::hoist()}}, \code{\link[tidyr:pack]{tidyr::pack()}} and
\code{\link[tidyr:pack]{tidyr::unpack()}} are not implemented yet.
}
\examples{
# TODO...
}
\seealso{
\code{\link[collapse:select_replace_vars]{collapse::num_vars()}} to easily keep only numeric columns from a
data frame, \code{\link[collapse:fscale]{collapse::fscale()}} for scaling and centering matrix-like
objects and data frames.
}
