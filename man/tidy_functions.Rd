% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidy_functions.R
\name{tidy_functions}
\alias{tidy_functions}
\alias{list_tidy_functions}
\alias{filter_ungroup}
\alias{mutate_ungroup}
\alias{transmute_ungroup}
\title{Tidy functions (mainly from {dplyr} and {tidyr}) to manipulate data frames}
\usage{
list_tidy_functions()

filter_ungroup(.data, ...)

mutate_ungroup(.data, ..., .keep = "all")

transmute_ungroup(.data, ...)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a lazy
data frame (e.g. from dbplyr or dtplyr). See \code{\link[=mutate]{mutate()}} for more details.}

\item{...}{Arguments dependent to the context of the function and most of
the time, not evaluated in a standard way (cf. the tidyverse approach).}

\item{.keep}{Which columns to keep. The default is \code{"all"}, possible values
are \code{"used"}, \code{"unused"}, or \code{"none"} (see \code{\link[=mutate]{mutate()}}).}
}
\value{
See corresponding "non-t" function for the full help page with
indication of the return values. \code{\link[=list_tidy_functions]{list_tidy_functions()}} returns a list of
all the tidy(verse) functions that have their speedy "s" counterpart, see
\link{speedy_functions}.
}
\description{
The Tidyverse defines a coherent set of tools to manipulate
data frames that use a non-standard evaluation and sometimes require extra
care. These functions, like \code{\link[=mutate]{mutate()}} or \code{\link[=summarise]{summarise()}} are defined in the
{dplyr} and {tidyr} packages. When using variants, like {dtplyr} for
\strong{data.frame} objects, or {dbplyr} to work with external databases,
successive commands in a pipeline are pooled together but not computed. One
has to \code{\link[=collect]{collect()}} the result to get its final form. Most of the tidy
functions that have their "speedy" counterpart prefixed with "s" are listed
with\code{\link[=list_tidy_functions]{list_tidy_functions()}}. Their main usages are (excluding less used
arguments, or those that are not compatibles with the speedy "s" counterpart
functions):
\itemize{
\item \code{group_by(.data, ...)}
\item \code{ungroup(.data)}
\item \code{rename(.data, ...)}
\item \code{rename_with(.data, .fn, .cols = everything(), ...)}
\item \code{filter(.data, ...)}
\item \code{select(.data, ...)}
\item \code{mutate(.data, ..., .keep = "all")}
\item \code{transmute(.data, ...)}
\item \code{summarise(.data, ...)}
\item \code{full_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{left_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{right_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{inner_join(x, y, by = NULL, suffix = c(".x", ".y"), copy = FALSE, ...)}
\item \code{bind_rows(..., .id = NULL)}
\item \code{bind_cols(..., .name_repair = c("unique", "universal", "check_unique", "minimal"))}
\item \code{arrange(.data, ..., .by_group = FALSE)}
\item \code{count(x, ..., wt = NULL, sort = FALSE, name = NULL)}
\item \code{tally(x, wt = NULL, sort = FALSE, name = NULL)}
\item \code{add_count(x, ..., wt = NULL, sort = FALSE, name = NULL)}
\item \code{add_tally(x, wt = NULL, sort = FALSE, name = NULL)}
\item \code{pull(.data, var = -1, name = NULL)}
\item \code{distinct(.data, ..., .keep_all = FALSE)}
\item \code{drop_na(data, ...)}
\item \code{replace_na(data, replace)}
\item \code{pivot_longer(data, cols, names_to = "name", values_to = "value")}
\item \code{pivot_wider(data, names_from = name, values_from = value)}
\item \code{uncount(data, weights, .remove = TRUE, .id = NULL)}
\item \code{unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)}
\item \code{separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE, convert = FALSE)}
\item \code{separate_rows(data, ..., sep = "[^[:alnum:].]+", convert = FALSE)}
\item \code{fill(data, ..., .direction = c("down", "up", "downup", "updown"))}
\item \code{extract(data, col, into, regex = "([[:alnum:]]+)", remove = TRUE, convert = FALSE)}
plus the functions defined here under.
}
}
\note{
The help page here is very basic and it aims mainly to list all the
tidy functions. For more complete help, see the {dplyr} or {tidyr} packages.
#' From {dplyr}, the \code{\link[=slice]{slice()}} and \code{slice_xxx()} functions are not added yet
because they are not available for {dbplyr}. Also \code{\link[=anti_join]{anti_join()}},
\code{\link[=semi_join]{semi_join()}} and \code{\link[=nest_join]{nest_join()}} are not implemented yet.
From {dplyr}, the \code{\link[=slice]{slice()}} and \code{slice_xxx()} functions are not added yet
because they are not available for {dbplyr}. Also \code{\link[=anti_join]{anti_join()}},
\code{\link[=semi_join]{semi_join()}} and \code{\link[=nest_join]{nest_join()}} are not implemented yet.
From {tidyr} \code{\link[=expand]{expand()}}, \code{\link[=chop]{chop()}}, \code{\link[=unchop]{unchop()}}, \code{\link[=nest]{nest()}}, \code{\link[=unnest]{unnest()}},
\code{\link[=unnest_longer]{unnest_longer()}}, \code{\link[=unnest_wider]{unnest_wider()}}, \code{\link[=hoist]{hoist()}}, \code{\link[=pack]{pack()}} and \code{\link[=unpack]{unpack()}} are
not implemented yet.
}
\examples{
# TODO...
}
\seealso{
\code{\link[collapse:select_replace_vars]{collapse::num_vars()}} to easily keep only numeric columns from a
data frame, \code{\link[collapse:fscale]{collapse::fscale()}} for scaling and centering matrix-like objects and data frames.
}
